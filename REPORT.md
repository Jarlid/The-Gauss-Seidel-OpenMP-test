### Немного болтовни про ожидания

Начнём с базы — после прочтения учебника возникли такие базовые предположения:

- Количество итераций при одном и том же входе в программу не должно измениться
  при использовании многопоточного алгоритма, ибо алгоритм должен быть детерминированным.
- На одном потоке многопоточный алгоритм должен работать несколько медленнее
  (из-за дополнительных затрат на создание и поддержание поточных структур),
  но при увеличении количества потоков многопоточный алгоритм должен ускоряться.
- Ускорение многопоточного алгоритма не должно быть линейно относительно количества потоков:
  если при первых увеличениях количества потоков ускорение касается всех блочных диагоналей,
  то при последующих затрагиваются только диагонали ближе к центру (они длиннее),
  ибо нельзя одновременно вычислять блоков больше, чем их в диагонали.

Также я считаю,
что сами функции f и g не должны влиять на время работы многопоточного алгоритма относительно однопоточного:
само вычисление функций никак потоками не затрагивается, только лишь относительное размещение данных массива,
и вычислений каждой функции происходит всегда одинаковое количество.

### Результаты

Так как я считаю, что функции f и g на относительные результаты не влияют, я использовал f и g из учебника.

Ниже приведена таблица результатов для этих f и g, N = 2000, размера блока = 100 и ε = 0.1
(в таблице представлено среднее по 10 запускам на одном и том же случайном входе):

| Алгоритм                            | Итерации | Время (с) | /    |
|-------------------------------------|----------|-----------|------|
| Однопоточный алгоритм               | 375      | 38.1099   | -    |
| Многопоточный алгоритм (1 поток)    | 375      | 41.4553   | 0.92 |
| Многопоточный алгоритм (2 потока)   | 375      | 22.2769   | 1.71 |
| Многопоточный алгоритм (4 потока)   | 375      | 14.2479   | 2.67 |
| Многопоточный алгоритм (8 потоков)  | 375      | 12.5342   | 3.04 |
| Многопоточный алгоритм (16 потоков) | 375      | 11.2588   | 3.38 |

Как можно заметить, мои предположения подтвердились.

### Технические детали

<details><summary>Описание вычислительной машины</summary>
<pre>
Процессор: AMD Ryzen 5 4600H with Radeon Graphics [3.00 GHz]
Оперативная память: 16.0 ГБ

ОС: Windows 10 (64-разрядная), версия 22H2

Система сборки: MinGW w64 9.0
CMake версии 3.23.2

Компилятор: GCC 11.2.0, стандарт C++14
Версия OpenMP: 4.5
</pre>
</details>

<details><summary>Чистый вывод прораммы</summary>
<pre>
Basic algorithm running...
10 runs finished!
Average loop count: 375
Average time:       38.1099 s

Parallel algorithm with 1 thread(s) running...
10 runs finished!
Average loop count: 375
Average time:       41.4553 s

Parallel algorithm with 2 thread(s) running...
10 runs finished!
Average loop count: 375
Average time:       22.2769 s

Parallel algorithm with 4 thread(s) running...
10 runs finished!
Average loop count: 375
Average time:       14.2479 s

Parallel algorithm with 8 thread(s) running...
10 runs finished!
Average loop count: 375
Average time:       12.5342 s

Parallel algorithm with 16 thread(s) running...
10 runs finished!
Average loop count: 375
Average time:       11.2588 s
</pre>
</details>